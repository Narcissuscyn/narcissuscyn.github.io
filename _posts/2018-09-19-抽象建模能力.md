---
  layout: post
  title:  "抽象建模能力(problems:37~40)"
  date:   2018-09-17 13:50:39
  categories: 剑指offer
  mathjax: true
---

* content
{:toc}
### 扑克牌顺子

```c++
bool cmp(const  int a, const int b)
{
	return a < b;
}
class Solution {
public:
	bool IsContinuous(vector<int> numbers) {
		int len = numbers.size();
		if (len == 0)return false;
		sort(numbers.begin(), numbers.end(), cmp);
		int interval = 0;
		int count_0 = 0;
		for (int i = 0; i < len - 1; i++)
		{

			if (numbers[i] != 0)
			{
				if (numbers[i + 1] == numbers[i])return false;
				interval += numbers[i + 1] - numbers[i] - 1;
			}
			else
			{
				count_0++;
			}
		}
		if (count_0 >=interval)return true;
		else
		{
			return false;
		}
	}
};
```

`思路：`

1. 排序
2. 遍历一遍，计算相邻两个数字之间差几个数字才能组成顺子，注意是除了0以外的数字，用interval保存，当interval的个数多于0的个数的话，就无法组成顺子了。
3. 处理特殊情况：numbers长度为0；有相等的数字；

###  圆圈中最后剩下的数（模拟循环链表或寻求简易思路）

```c++
class Solution {
public:
    
	int LastRemaining_Solution(int n, int m)
	{
		if (n < 1 || m < 1)return -1;
		int last = 0;
		for (int i = 2; i <=n; i++)
		{
			last = (last + m) % i;
		}
		return last;
	}
 
};
```

`思路`这种简便的还是不太会，只会循环链表的：

```c++
class Solution {
public:
    
	int LastRemaining_Solution(int n, int m)
	{
		if (n < 1 || m < 1)return -1;//特殊情况

		vector<int>l;//构造额外空间存储
		for (int i = 0; i < n; i++)l.push_back(i);
		int pos = 0;

		while (l.size()!=1)
		{
			int r_pos = pos + m-1 ;//当前要移除节点的位置
			if (r_pos >=l.size())
			{
				r_pos %= l.size();//处理循环带来的索引变化。一定是取模，因为有可能循环好几遍。
			}
			l.erase(l.begin()+r_pos);//删除数m-1的节点
			pos =r_pos;//由于删除一个节点，下一个数0的位置变成当前移除的节点位置
		}
		return l.front();
	}
};
```



### 求1+2+3+......+n（不能使用部分操作）

```c++
class Solution {
public:
	int Sum_Solution(int n) {
		if (n == 1)return 1;
		return n + Sum_Solution(n - 1);
	}
};
```

`思路`由于此题说不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C），一看题目要求，立马就想到了递归，只用到了加法，但是仔细一看，还用到了if条件语句，肯定不行。剑指ofer上面提供了四种解法：

#### 构造函数法(循环角度)

```c++

class Temp
{
public:
	Temp() { ++N; Sum += N; }//在构造函数里面实现每次加运算
	~Temp();
	static void Reset() { N = 0, Sum = 0; }//注意函数和变量都设置成静态的，能通过类调用。
	static int GetSum() { return Sum; }
private:
	static int N;
	static int Sum;
};
int Temp::N = 0;
int Temp::Sum = 0;
Temp::~Temp()
{
}
class Solution {
public:
	int Sum_Solution(int n) {
		Temp::Reset();
		Temp*a = new Temp[n];//调用n次构造函数
		delete a;
		a = NULL;
		return Temp::GetSum();
	}
};
```

#### 虚函数方法(递归角度：c++)

```c++
class A;
A* Array[2];

class A
{
public:
	A();
	~A();
	virtual int sum(int n) { return 0; }//基类的虚函数
private:

};

A::A()
{
}

A::~A()
{
}


class B:public A
{
public:
	B();
	~B();
	virtual int sum(int n)
	{
		return Array[!!n]->sum(n - 1) + n;//这里有个技巧:n>0,!!n=1,否则n==0,则!!n=0;根据0和1的标识来判断调用A的函数还是B的函数注意是Array[!!n]调用的，而不是Array[!!(n-1)],这也就是第一次是用Array[1]调用的原因
	}
private:

};

B::B()
{
}

B::~B()
{
}

class Solution {
public:
	int Sum_Solution(int n) {
		A a;
		B b;
		Array[0] = &a;
		Array[1] = &b;//虚函数的作用：基类4可以调用子类的方法

		int value = Array[1]->sum(n);
		return value;
	}
};
```



#### 函数指针求解(递归角度：c)

```c++
typedef int(*fun)(int);
int terminator(int n) { return 0; }
int sum(int n)
{
	static fun f[2] = { terminator,sum };
	return n + f[!!n](n - 1);
}
class Solution {
public:
	int Sum_Solution(int n) {

		return sum(n);
	}
};
```

c里面没有虚函数，因此用函数指针的方法

#### 模板类型求解

```c++
template <int n>struct Sum
{
	enum Value{N=Sum<n-1>::N+n};
};
template<>struct Sum<1>
{
	enum Value { N = 1 };

};
```

在编译中实现，但是不清除如何调用，或者说怎么通过oj

缺点：不能动态输入，n不能太大



#### 逻辑与的短路特性(牛客上还有很多新颖的思路)

```c++
链接：https://www.nowcoder.com/questionTerminal/7a0da8fc483247ff8800059e12d7caf1
来源：牛客网

解题思路：
1.需利用逻辑与的短路特性实现递归终止。 2.当n==0时，(n>0)&&((sum+=Sum_Solution(n-1))>0)只执行前面的判断，为false，然后直接返回0；
3.当n>0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。
    public int Sum_Solution(int n) {
        int sum = n;
        boolean ans = (n>0)&&((sum+=Sum_Solution(n-1))>0);
        return sum;
    }
```



### 不用加减乘除做加法（只剩下位运算，二进制模拟十进制加法运算）**

```c++
class Solution {
public:

	int Add(int num1, int num2)
	{
		int sum=0, carray=0;
		do
		{
			sum = num1^num2;
			carray= (num1&num2) << 1;//进位应该加到下一位上，所以要左移
			num1 = sum;
			num2 = carray;
		} while (num2!=0);//注意可能产生多次进位，所以要用循环
		return sum;
	}
};
```

