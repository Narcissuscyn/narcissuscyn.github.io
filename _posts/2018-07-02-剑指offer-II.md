---
  layout: post
  title:  "知识迁移能力"
  date:   2018-07-02 13:50:39
  categories: 剑指offer
  tags: 数组 二叉树 字符串
  mathjax: true
---

* content
{:toc}



### 数字在排序数组中出现的次数

```c++
class Solution {
public:
	int GetNumberOfK(vector<int> data, int k) {
		int count = 0;
		for (int i = 0; i < data.size(); i++)
		{
			if (data[i] == k)count++;
		}
		return count;
	}
};
```

这个代码虽然简单，但是当面试时问道这个问题时，一定不要简单的这么回答，看看题目就知道，这么简单的题目，而且是排序数组，怎么会就直接遍历一遍呢。明显要用到二叉搜索，降低时间复杂度由$O(n)$到$O(log(n))$；

```c++
class Solution {
public:

	int GetNumberOfK(vector<int> data, int k) {

		int count = 0;
		if (data.size() != 0)
		{
			int min = getMinIdx(data, k, 0, data.size() - 1);
			int max = getMaxIdx(data, k, 0, data.size() - 1);
			if (min != -1 && max != -1)
			{
				count = max - min + 1;
			}
		}
		return count;
	}

	int getMinIdx(vector<int> data, int k, int l,int r)
	{
		if (l > r)return -1;
		int mid = (l + r) / 2;
		if (data[mid] < k) {
			l = mid + 1;
		}
		else if(data[mid]>k)
		{
			r = mid - 1;
		}
		else
		{
			if (mid>0&&data[mid - 1] == k)
			{
				r = mid - 1;
			}
			else
			{
				return mid;
			}
		}
		return getMinIdx(data, k, l, r);
	}
	int getMaxIdx(vector<int> data, int k, int l,int r)
	{
		if (l > r)return -1;
		int mid = (l + r) / 2;
		if (data[mid] < k) {
			l = mid + 1;
		}
		else if (data[mid]>k)
		{
			r = mid - 1;
		}
		else
		{
			if (mid<data.size()-1&&data[mid +1] == k)
			{
				l= mid +1;
			}
			else
			{
				return mid;
			}
		}
		return getMaxIdx(data, k, l, r);

	}
};
```

`思路`分别递归的二叉树搜索k出现的最小下标和最大下标。



### 二叉树的深度

```c++


#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
#include<queue>
using namespace std;


struct TreeNode {
int val;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int x) :
val(x), left(NULL), right(NULL) {
}
};
class Solution {
public:
	TreeNode*create_tree(TreeNode *root)
	{
		
		char ch;
		if ((ch = getchar()) == '#')root = NULL;//其中getchar（）为逐个读入标准库函数 
		else {
			root = new TreeNode(ch);//产生新的子树 
			create_tree(root->left);//递归创建左子树 
			create_tree(root->right);//递归创建右子树 
		}
		return root;
	}
	int TreeDepth(TreeNode* p)
	{
		if (p == NULL)
			return 0;//注意空数的深度是1
		int h1 = TreeDepth(p->left);
		int h2 = TreeDepth(p->right);
		if (h1>h2)return (h1 + 1);
		return h2 + 1;
	}
};
int main()
{
	Solution solver;
	TreeNode *root = NULL;
	solver.create_tree(root);
	int result = solver.TreeDepth(root);
	return 0;
}
```

`思路`比较简单，不要想太复杂了。



### 平衡二叉树

```c++
class Solution {
public:
	int TreeDepth(TreeNode* p)
	{
		if (p == NULL)
			return 0;
		int h1 = TreeDepth(p->left);
		if (h1 == -2)return -2;
		int h2 = TreeDepth(p->right);
		if (h2 == -2)return -2;
		if (abs(h1 - h2) > 1)return -2;
		if (h1>h2)return (h1 + 1);
		return h2 + 1;
	}

	//39平衡二叉树
	bool IsBalanced_Solution(TreeNode* pRoot) {
		if (pRoot == NULL)
			return true;
		int h = TreeDepth(pRoot);
		if (h ==-2)return false;
		return true;
	}
};
```

`思路`把求深度的代码改一下，一旦出现不平衡的节点就直接返回-2，返回-2的原因是怕有的题里面要求空节点的深度为-1.此算法不需要重复遍历二叉树节点。



### 数组中只出现一次的数字

```c++
class Solution {
public:
	void FindNumsAppearOnce(vector<int> data, int* num1, int *num2) {
		//所有的数字求一次异或，相同数字异或的结果是0，and_result是那两个只出现一次的数字的异或结果
        int and_result=data[0];
		for (int i = 1; i < data.size(); i++)
		{
			and_result ^= data[i];
		}
		*num1 = 0;
		*num2 = 0;
        //找到异或结果，从右边看，第一次出现1的索引；
		int idx = findFstIdxOf1(and_result);
        //根据索引位置的值是不是1，将整个数组data分成两份：每一份都有一个只出现一次的数字和一些出现两次的数字；而只有一个出现一次的数字，直接把每一份中的元素求异或就能得到该指出现一次的元素的值。
		for(int i=0;i<data.size();i++)
		{ 
			if (isIdx1(data[i],idx))
			{
				*num1 ^= data[i];
			}
			else
			{
				*num2 ^= data[i];

			}
		}

	}

	int findFstIdxOf1(int num)
	{
		int idx = 0;
		while (((num&1)==0)&&(idx<8*sizeof(int)))
		{
			num = num >> 1;
			idx++;
		}
		return idx;
	}

	bool isIdx1(int num,int idx)
	{
		num = num >> idx;
		if ((num & 1) == 0)return true;
		return false;
	}
};
```

`思路`就是按照剑指offer的讲解，将数组分成两份分别查找。



### 和为S的连续正数序列

```c++
class Solution {
public:
	vector<vector<int> > FindContinuousSequence(int sum) {
		vector<vector<int>> sequence;
		if (sum == 0) return sequence;
		int mid = sum / 2+1;
		for (int i =1; i < mid; i++)
		{
			int count = 2;
			int cur_sum = 0;
			while (cur_sum<sum)
			{
				cur_sum = (i + (i + count-1))*count/2;
				if (cur_sum == sum)
				{
					vector<int>cur_seq;
					for (int j = i; j < i + count; j++)
					{
						cur_seq.push_back(j);
					}
					sequence.push_back(cur_seq);
					i++;//这里i++是因为找到一个数组后，i可以从i+2开始下一次寻找，而不需要从i+1开始，因为从i+1开始一定找不到。分析下就知道了。
					break;
				}
				count++;
			}
		}
		return sequence;
	}
};
```

`思路：`和的简便计算方法就是(n-m+1)(n+m)/2，其中m是第一个数，n是第二个数。第一层循环当i自增发哦sum的一半的时候就不需要继续找了，第二层循环count不断增大，直到找到一串数或者cur_sum大于sum就停止。我这个方法和剑指offer上的方法都是两层循环，但是他的复杂度还是会比我的低一点，原因在于他找多个数组的时候任然借用找一个数组的方法，头尾分别两个指针，向内靠拢；但是外层循环的结束条件是首指针大于尾指针，所以每次找一个数组的时候，尾指针也可能往后移动。而我的方法，在每招找一个数组的时候，都需要count从2开始递增，应该会比他的方法慢点



### 和为S的两个数

```c++
class Solution {
public:
	vector<int> FindNumbersWithSum(vector<int> array, int sum) {
		vector<int>result;
		int beg = 0, end = array.size() - 1;
		while (beg<end)
		{
			int cur_sum = array[beg] + array[end];
			if (cur_sum==sum)
			{
				result.push_back(array[beg]);
				result.push_back(array[end]);
				break;
			}
			if (cur_sum > sum)
			{
				end--;
			}
			else
			{
				beg++;
			}
		}
		return result;
	}
};
```

`思路：`头尾两个指针，向内收缩，找到的第一个和是sum的就是最小的，为什么是最小的，是可以证明的，比如n,n+x,n+y,n+z;n+(n+z)=(n+x)+(n+y)，那么n*(n+z)一定小于(n+x)*(n+y)的。



### 左旋转字符串

```c++
class Solution {
public:

	string LeftRotateString(string str, int n) {
		int len = str.length();
		if (len == 0|| n>len)return str;
		return str.substr(n, len - n) + str.substr(0, n);
	}
};
```

比调用reverse函数要简单点吧。



### 翻转单词顺序列

```c++
class Solution {
public:
	string ReverseSentence(string str) {
		int len = str.length();
		string result;
        //字符串整体反转
		for (int i =  len- 1; i >= 0; i--)
		{
			result.push_back(str[i]);
		}
        //反转字符串的每个单词
		int gap = 0;
		for (int i = 0; i < len; i++)
		{
			if (result[i] == ' ')
			{
				reverse(result, i -gap,i-1);
				gap = -1;
			}
			if (i == len - 1)
			{
				reverse(result, i - gap, i);
			}
			gap++;
		}
		return result;
	}
    //反转字符串的一部分
	void reverse(string&str,int begin,int end)
	{
		while (begin<end)
		{

			char temp = str[begin];
			str[begin] = str[end];
			str[end] = temp;
			begin++;
			end--;
		}
	}
};
```

