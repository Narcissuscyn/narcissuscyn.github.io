---
  layout: post
  title:  "字符串和数组"
  date:   2018-07-22 13:50:39
  categories: 剑指offer
  tags: 数组 字符串
  mathjax: true
---

* content
{:toc}

### 把字符串转换成整数

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	int StrToInt(string str) {
		int flag = 1;
		int star_pos = 0;//star_pos标识符号位
		if (str[0] == '+') { star_pos = 1; }
		if (str[0] == '-') { flag = -1; star_pos = 1; }
		int base = 1;
		long long number = 0;
		for (int i = str.length() - 1; i >= star_pos; i--)
		{
			if (str[i] >= '0'&& str[i] <= '9')
			{
				number += (str[i] - '0')*base;//乘基再加上前一步的和number
				base *= 10;
			}
			else
			{
				return 0;
			}
		}
		return number*flag;//flag标识正负数
	}
};

int main()
{
	Solution solver;
	return 0;
}
```



### 数组中重复的数字

```c++
class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
	bool duplicate(int numbers[], int length, int* duplication) {
		map<int, int> m;

		for (int i = 0; i < length; i++)
		{
			if (m.find(numbers[i]) == m.end())
			{
				m[numbers[i]] = 1;
			}
			else
			{
				*duplication = numbers[i];
				return true;
			}
		}
		return false;
	}
};
```

### 构建乘积数组

```c++
class Solution {
public:
	vector<int> multiply(const vector<int>& A) {
		vector<int>b,c,d;
		int len = A.size();
		if (len == 0)return b;
		c.push_back(A[0]);
		d.push_back(A[len-1]);
		for (int i = 1; i < len-1; i++)//计算c[i]=c[i-1]*A[i];d[i]= d[i-1]*A[len - i - 1]
		{
			c.push_back(c[i-1]*A[i]);
			d.push_back(A[len - i - 1] * d[i-1]);
		}
		c.push_back(c[len - 2] * A[len - 1]);//最后一个元素
		d.push_back(d[len - 2] * A[0]);//第一个元素
		for (int i = 0; i < len; i++)
		{
			if (i == 0)b.push_back(d[len - 1]);//利用c和d计算b:b[i]=c[i-1]*d[len-i-2],即除去第i个元素的乘积
			else if (i == len - 1)b.push_back(c[len - 2]);
			else
			{
				b.push_back(c[i - 1] * d[len - i - 2]);
			}
		}

		return b;
	}
};
```

`思路`用两个辅助数组来存.



### 正则表达式匹配

```c++
	bool match(char* str, char* pattern)
	{
		if (str == nullptr || pattern == nullptr)
			return false;

		return matchCore(str, pattern);
	}

	bool matchCore(char* str, char* pattern) {
		if (*str == '\0' && *pattern == '\0')
			return true;
		//str不为空，pattern为空时,返回false;反过来则不成立
		if (*str != '\0' && *pattern == '\0')
			return false;
		//当前字符的下一个字符为*时
		if (*(pattern + 1) == '*') {
			if (*pattern == *str || (*pattern == '.' && *str != '\0')) {//当前字符匹配，则有3种情况：
				//1.aba和ab*a
				//2.abba和ab*a
				//3.aa和aa*a
				//三种情况，只要有一种为真即可
				return matchCore(str + 1, pattern + 2) || matchCore(str + 1, pattern) || matchCore(str, pattern + 2);
			}
			else//当前字符不匹配aaa和aab*a
				return matchCore(str, pattern + 2);
		}
		//当前字符的下一个字符不为*时
		if (*pattern == *str || (*pattern == '.' && *str != '\0'))
			return matchCore(str + 1, pattern + 1);

		return false;
	}

```

`思路`这道题没想到要根据有没有*来讨论情况，我写的时候虽然也是讨论的各种情况，但是思路没有这么清晰，有些用递归的想法，但是也没想清楚怎么用。

1. str和pattern都为空，返回true；
2. str不为空，pattern为空时,返回false;反过来则不成立
3. 当前字符的下一个字符为*时:
   - 当前字符匹配，则有3种情况,三种情况，只要有一种为真，即返回true：
     - aba和ab*a
     - abba和ab*a
     - aa和aa*a
   - 当前字符不匹配：aaa和aab*a
4. 当前字符的下一个字符不为*时，只需匹配当前字符，匹配上，则返回true。



###  表示数值的字符串

```c++
链接：https://www.nowcoder.com/questionTerminal/6f8c901d091949a5837e24bb82a731f2
来源：牛客网

    bool isNumeric(char* str)
    {
        if (str == NULL)
        return false;
    if (*str == '+' || *str == '-')
        ++str;
    if (*str == '\0')
        return false;
    int x = 0;    //标记整数部分
    int digit = 0; //标记小数点
    int e = 0;     //标记e的状态
    while (*str != '\0')
    {
        //标记整数部分的状态
        if (*str >= '0' && *str <= '9')
        {
            ++str;
            x = 1;
        }
        //小数点
        else if (*str == '.')
        {
            //前面已经出现过小数点或小数点之前存在e，则返回false
            if (digit > 0 || e > 0)
                return false;
            ++str;
            digit = 1;    //标记小数点已经出现过
        }
 
        //e
        else if (*str == 'e' || *str == 'E')
        {
            //e之前没有整数或e已经出现过，则返回false
            if (x == 0 || e > 0)
                return false;
            ++str;
            e = 1;     //标记e表示已经出现过
 
            //e之后可以出现+-号再加整数
            if (*str == '+' || *str == '-')
                ++str;
            //e之后没有数据也不行
            if (*str == '\0')
                return false;
        }
        else
            return false;
    }
    return true;
    }
 
```



### 字符流中第一个不重复的字符

```c++
class Solution
{
public:
	string s;//用字符串s保存字符流中的字符
	map<int, int>m;//用一个map计数
	//Insert one char from stringstream
	void Insert(char ch)//计数及构造字符串
	{
		s += ch;
		m[ch]++;
	}
	//return the first appearence once char in current stringstream
	char FirstAppearingOnce()//查找第一次出现一次的字符,O(n)的时间复杂度
	{
		for (int i = 0; i < s.length(); i++)
		{
			if (m[s[i]] == 1)return s[i];
		}
		return '#';
	}


};
```

