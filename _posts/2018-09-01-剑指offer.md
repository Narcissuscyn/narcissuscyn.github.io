---
  layout: post
  title:  "剑指offer"
  date:   2018-09-01 13:50:39
  categories: SwordOffer
  tags: SwordOffer
  mathjax: true
---

### 剑指offer

* content
{:toc}
### 二维数组中的查找

`我的思想`：此题在于边界的考虑，算法思想是在每一行进行一个二分查找

```python
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # array=np.array(array)
        # write code here
        if array==[[]]:
            return False
        l = len(array[0])
        row=array.__len__()
        for i in range(row):
            min = 0
            max=l
            pre=-1
            idx=0
            while(pre!=idx):
                idx = int(((min + max)/2))
                pre=idx
                if target < array[i][idx]:
                    max=idx
                    idx =int(((idx+min) / 2))
                elif target > array[i][idx]:
                    min=idx
                    idx =int(( (idx + max) / 2))
                else:
                    return True
        return False
array=[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
solve=Solution()
if solve.Find(7,array):
    print("yes")
else:
    print("No")
```

`更好解答`：

### 替换空格

```c++
#include<iostream>

#include<string>
using namespace std;

class Solution {
public:
	void replaceSpace(char *str, int length) {
		string a = "";
		int idx = 0;
		for (int i = 0; i < length; i++)
		{

			if (str[i] != ' ')
			{
				//a.push_back(str[i]);
				a.append(sizeof(char), str[i]);
				//cout << (typeid(str[i])== typeid(char));
				idx++;

			}
			else
			{
				idx += 3;
				a.append("%20");
			}
		}
		str=strcpy(str, a.c_str());

		//str = (char*)a.c_str();这个方法提交不成功，只修改了形参str，上面那句话可以！这个地方需要仔细研究下赋值问题，类似swap(a,b)
	}
};

int main()
{
	Solution solver;
	solver.replaceSpace("hello world", 11);
	getchar();
	return 0;
}

```

`string 字符串拼接的几种方法:`

```c++
y:string d:char，d是string可以直接append(d)
1)y += d
2)std::string y("Hello worl");
y.push_back('d')
3)s.append(sizeof(char), d);
4）s.append(1, d);
```

`将string转换成char*字符串`:

```c++
data();

如：

string str="abc";

charp=(char)str.data();

2.c_str();

如：

string str="adcd";

char p=(char)str.c_str();

```

`O(n)的复杂度`，用python当然简单了这题，几行代码搞定。

### 从尾到头打印链表

```c++
#include<iostream>

#include<string>
#include<vector>
using namespace std;


struct ListNode {
	int val;
    struct ListNode *next;
    ListNode(int x) :
		val(x), next(NULL) {
       }
};


class Solution {
public:
	//3 从头到尾打印链表
	vector<int> printListFromTailToHead(ListNode* head) {
		vector<int> a,b;
		if (head == NULL)
		{
			return a;
		}
		ListNode* temp = head;
		while (temp!=NULL)
		{
			cout << temp->val;
			a.push_back(temp->val);
			temp = temp->next;
		}
		for (int i = a.size()-1; i >=0 ; i--)
		{
			b.push_back(a[i]);
		}
		return b;
	}
};

int main()
{
	Solution solver;
	ListNode*head = NULL;
	head =new ListNode(1);
	head->next= new ListNode(2);
	solver.printListFromTailToHead(head);
	getchar();
	return 0;
}
```

这个题目比较简单遍历两次即可。第二个遍历也可利用#include <algorithm> 中的排序函数`reverse(a.begin(),a.end()) `其实现如下：

```c++
template <class BidirectionalIterator> void reverse (BidirectionalIterator first, BidirectionalIterator last)
{
     while ((first!=last)&&(first!=--last))
     {
          std::iter_swap (first,last);
          ++first;
     }
}
```

我试了vector的reverse，，没成功：

```c++
arrayInt=...
vector<int> arrayRever;
arrayRever.reserve(arrayInt.size());
```

![1534345792071](C:\Users\nian.000\AppData\Local\Temp\1534345792071.png)

### 根据先序和中序建立二叉树

```c++
TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		//只有一个节点，直接返回该节点
		if (pre.size() == 1|| vin.size()==1)
		{
			return  new TreeNode(pre[0]);
		}
		//寻找先序的头结点在中序序列中的位置
		int root_val = pre.front();
		TreeNode*root = new TreeNode(root_val);

		vector <int>::iterator it = find(vin.begin(),vin.end(), root_val);
		int nPosition = -1;
		if (it != vin.end())
		{
			nPosition = distance(vin.begin(), it);
		}
		//建立左子树和右子树
		vector<int> l_vin, r_vin;
		vector<int> l_pre,r_pre;
		if (nPosition == 0)//左子树为空
		{
			root->left = NULL;
		}
		else//得到左子树的pre和vin序列，并递归调用。
		{
			l_pre=vector<int>(&pre[1], &pre[nPosition]);
			l_pre.push_back(pre[nPosition]);
			l_vin.assign(vin.begin(), it);
			root->left = reConstructBinaryTree(l_pre, l_vin);
			
		}
		if (nPosition == vin.size() - 1)//右子树为空
		{
			root->right = NULL;
		}
		else//得到右子树的pre和vin序列，并递归调用。
		{
			r_pre=vector<int>(&pre[nPosition+1], &pre[pre.size()-1]);
			r_pre.push_back(pre[pre.size() - 1]);
			r_vin.assign(it+1,vin.end() );
			root->right = reConstructBinaryTree(r_pre, r_vin);
		}
		
		return root;
	}
```

`主要思想:`在于`递归`的创建左子树和右子树。

`复制vector一部分的两种方法：`

- ```c++
  1.l_vin.assign(vin.begin(), it);
  2.l_pre=vector<int>(&pre[1], &pre[nPosition]);
  //注意：第二种方法是前闭后开的。第一种方法是闭的。
  ```

`根据中序和后续序列创建二叉树：`和根据先序和中序创建二叉树的道理是一样的，只是后序序列的根节点是最后一个节点。

### 用两个栈实现队列

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

class Solution
{
public:
	void push(int node) {
		if (stack1.empty())
		{
			stack1.push(node);
		}
		else
		{
			while (!stack1.empty())
			{
				stack2.push(stack1.top());
				stack1.pop();
			}
			stack2.push(node);
			while (!stack2.empty())
			{
				stack1.push(stack2.top());
				stack2.pop();
			}

		}
	}

	int pop() {
		int a = stack1.top();
		stack1.pop();
		return a;
	}

private:
	stack<int> stack1;
	stack<int> stack2;
};

int main()
{
	Solution solver;
	solver.push(1);
	solver.push(2);
	solver.push(3);
	solver.pop();
	return 0;
}
```

`思路：`将数据存在一个栈中，在push的时候通过令一个栈中转，实现把数据压入底部，pop的时候可以直接利用stack的pop即可；当然反过来pop的时候利用另一个栈中转，push的时候直接利用stack的push也是可以的。

### 旋转数组的最小值

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	int minNumberInRotateArray(vector<int> rotateArray) {
		int len = rotateArray.size();
		if (len == 0)
		{
			return 0;
		}
		else
		{
			int da = 1;
			for (int i = 1; i < len; i++)
			{
				da = rotateArray[i] - rotateArray[i - 1];
				if (da < 0)//小于0即递减的位置
				{
					return rotateArray[i];
				}
			}
		}
		return rotateArray[0];
	}
};

int main()
{
	Solution solver;
	//3.
	//input:3 4 5 1 2 s
	vector<int> a;
	int val = 0;
	while (cin >> val)
	{
		a.push_back(val);
	}
	cout << solver.minNumberInRotateArray(a) << endl;
	getchar();
	return 0;
}
```

`思路`只要找到递减的位置输出即可

### 斐波那契数列

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

//F0 = 0     (n = 0)
//F1 = 1    (n = 1)
//Fn = F[n - 1] + F[n - 2](n = >2)
int a[10000] = { 0 };
class Solution {
public:
	
	int Fibonacci(int n) {
		if (n == 0)
		{
			a[0] = 0;
			return 0;
		}
		else if(n==1)
		{
			a[1] = 1;
			return 1;
		}
		if (a[n] == 0)
		{
			a[n] = Fibonacci(n - 1) + Fibonacci(n - 2);
			return a[n];
		}
		else
		{
			return a[n];
		}

	}
};

int main()
{
	Solution solver;
	cout<<solver.Fibonacci(4);
	getchar();
	return 0;
}
```

`思路`[参考文章](https://github.com/qiwsir/algorithm/blob/master/fibonacci.md)，如果直接用递归而不存储中间结果的话，肯定是超时的，因此要用一个数组保存前面已经计算的结果。还有一些快速实现的思路，以下来自参考文章：

- 用迭代的方式实现：

  ```python
  def fib3(n):
      a, b = 0, 1
      for i in range(n):
          a, b = b, a+b
      return a
  ```

- 用数学理论结论：

  ```python
  print('!* Fibonacci Sequence python \n')
  def Fibonacci_Series():
      x = input('Enter Series length to print fibonacci sequence')
  
      d,e=0,1
      a = []
      a.append(d)
      a.append(e)
      while(x!=2):
          c = d + e
          d = e
          e = c
          a.append(c)
          x = x -1
      print(a)
  ```

### (8,9)跳台阶（重要，有变种，比如每次跳2的整数次幂）

- 每次1-2台阶

  ```c++
  class Solution {
  public:
  int a[10000] = { 0 };
  	//in the n-th floor
  	int jumpFloor(int number) {
  		if ((number == 1) || (number == 0)||(number==2))
  		{
  			return number;
  		}
  		if (a[number] == 0)
  		{
  			a[number] = jumpFloor(number - 1) + jumpFloor(number - 2);
  			return a[number];
  		}
  		return a[number];
  	}
  };
  ```

  和问题7的解法一样。

- 每次1-n个台阶

  ```c++
  class Solution {
  public:
      int a[10000] = { 0 };
  //dynamic programing?no!
  	int jumpFloorII(int number) {
  		if (number == 1 || number == 0)
  		{
  			return 1;
  		}
  		if (a[number] == 0)
  		{
  			a[number] = 2 * jumpFloorII(number - 1);
  		}
  		return a[number];
  	}
  };
  ```

  `思路`关键是推导数关系式 $ Fib(n) = 2*Fib(n-1) $,[参考文章](https://blog.csdn.net/Hackbuteer1/article/details/6686747)

### 矩形覆盖

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	int a[100000] = { 0 };
	int rectCover(int number) {

		if (number == 0)
		{
			return 0;
		}
		if (number == 1 || number == 2)
		{
			return number;
		}
		if (a[number] == 0)
		{
			a[number] = rectCover(number - 2)+rectCover(number-1);
		}
		return a[number];
	}
};
int main()
{
	Solution solver;
	cout<<solver.rectCover(3);

	return 0;
}
```

`思路`其实和前两题类似，主要考虑n来自于哪几种情况，再递归的加起来即可，这题，2*n的覆盖来自于2*(n-1)和2(n-2)两种情况。

### 二进制数中1的个数

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
#include<math.h>
using namespace std;
class Solution {
public:
	vector<int>a;
	int  NumberOf1(int n) {
		bool flag = true;
		if (n < 0)
		{
			flag = false;
		}
		n = abs(n);
		while (n!=0)
		{
			if (n % 2 == 1)
			{
				a.push_back(1);
			}
			else
			{
				a.push_back(0);
			}
			n = n / 2;

		}
		if (!flag)
		{
			while (a.size()<31)
			{
				a.push_back(0);
			}
			a.push_back(1);

			for (int i = 0; i < a.size()-1; i++)//reverse
			{
				if (a[i] == 1)
				{
					a[i] = 0;
				}
				else
				{
					a[i] = 1;

				}
			}
			for (int i = 0; i < a.size()-1; i++)//add 1
			{
				a[i] += 1;
				if (a[i] == 2)
				{
					a[i] = 0;
				}
				else
				{
					break;
				}
			}
			

		}
		
		int count = 0;
		for (int i = 0; i < a.size(); i++)
		{
			if (a[i] == 1)
			{
				count++;
			}
		}
		return count;
	}
};

int main()
{
	//-2147483648
	Solution solver;
	cout<<solver.NumberOf1(-1);
	return 0;
}
```

`思路`这个题目主要是要考虑整型(`int`)是32位的.当n为负数时要在第32位添加1，其它位要取反加1.

### 数值的整数次方

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	double Power(double base, int exponent) {
		bool flag = true;
		double result = 1;
		if (exponent < 0)
		{
			flag = false;
			exponent = -exponent;
		}
		for (int i = 0; i < exponent; i++)
		{
			result *= base;
		}
		if (!flag)
		{
			result = 1 / result;
		}
		return result;
	}
};

int main()
{
	Solution solver;
	solver.Power(2, -3);
	return 0;
}
```

`思路`这题主要是要考虑到指数为负数的情况。

### 调整数组顺序使奇数位于偶数前面

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	void reOrderArray(vector<int> &array) {
		vector<int> old,even;
		for (int i = 0; i < array.size(); i++)
		{
			if (array[i] % 2 == 0)
			{
				even.push_back(array[i]);
			}
			else
			{
				old.push_back(array[i]);
			}
		}
		old.insert(old.end(), even.begin(), even.end());
		array = old;

	}
};

int main()
{
	Solution solver;
	return 0;
}
```

`思路`两个数组分别存奇数和偶数，再把偶数拼接在奇数后面即可，最后由于array是引用，直接赋值给array即可；

### 链表中倒数第k个节点

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

struct ListNode {
int val;
struct ListNode *next;
ListNode(int x) :
val(x), next(NULL) {
}
};
class Solution {
public:
	ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL||pListHead->next==NULL)
		{
			return NULL;
		}
		ListNode* node_k= pListHead, *nex= pListHead;

		int interval = 0;

		while (nex->next!=NULL)
		{
			nex = nex->next;
			interval ++;
		}
		if (interval < k-1)
		{
			return NULL;
		}
		else
		{
			while (interval>k-1)
			{
				node_k = node_k->next;
				interval--;
			}
		}		
		return node_k;
	}
};

int main()
{
	Solution solver;
	ListNode*head= new ListNode(0), *tail = NULL;
	//head->next = new ListNode(1);
	tail = head;
	for (int i = 1; i <= 5; i++)
	{
		tail->next = new ListNode(i);
		tail = tail->next;
	}
	solver.FindKthToTail(head, 1);
	return 0;
}
```

`思路`用两个指针，一个指针遍历到最后一个节点，记住这期间经过了多好次->next，也就是interval的值，然后另一个指针也从头向尾遍历，直到interval减少至k-1

这里需要注意的地方就是输入的链表，第一个节点就是head节点，它同时是有值的，比如说输入{1,2,3,4,5}那么head节点的值就是1，接下来2,3,4,5

### 反转链表

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
	ListNode* ReverseList(ListNode* pHead) {
		if (pHead == NULL)
			return NULL;
		if (pHead->next == NULL)
			return pHead;
		ListNode*temp, *tail=pHead->next,*pre=pHead;
		while (tail->next != NULL)
		{
			temp = tail->next;//保存当前节点的下一节点
			tail->next = pre;//更改当前节点的指针指向上一节点
			pre = tail;//pre保存当前节点
			tail = temp;//tail指向temp
		}
		tail->next = pre;//最后一个节点的指针也要更新下
		pHead->next = NULL;//更新头节点的指针
		return tail;
	}
};
```

### 合并两个排序链表

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
	{
		if (pHead1 == NULL &&pHead2 == NULL)
			return NULL;

		if (pHead1 == NULL)return pHead2;
		if (pHead2 == NULL) return pHead1;
		ListNode*temp_big, *temp_small,*final, *temp=NULL;

		if (pHead1->val < pHead2->val)
		{
			temp_big = pHead2;
			temp_small = pHead1;
		}
		else
		{
			temp_big = pHead1;
			temp_small = pHead2;
		}
		final = temp_small;
		
		while (temp_small!=NULL)
		{
			//循环处理temp_small，当temp_small的值大于temp_big时交换指针
			while (temp_small!=NULL &&temp_small->val<=temp_big->val)
			{
				temp = temp_small;
				temp_small = temp_small->next;
			}
			if (temp_small != NULL)
			{
				temp->next = temp_big;
				temp=temp_small;
				temp_small = temp_big;//这个地方不能赋值为temp_big->next，因为temp_big->next为空时，下面那句赋值语句会没有变量指向final的尾指针。
				temp_big = temp;
			}
		}
		if (temp_big != NULL)
		{
			temp->next = temp_big;//多出来的部分加上去
		}
		return final;
	}
};
```

`思路`这道题其实不用新建链表，不断的交换指针即可。有点需要注意：

- temp_small遍历到空指针时要考虑将剩下的temp_big里的节点接到final上去；

### 树的子结构

```c++
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
	val(x), left(NULL), right(NULL) {
	}
};

class Solution {
public:
	bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
	{
		bool result = false;
		if (pRoot1 != NULL&&pRoot2 != NULL)
		{
			if (pRoot1->val == pRoot2->val)
			{
				result = isEqueal(pRoot1, pRoot2);
				if (!result)result = HasSubtree(pRoot1->left, pRoot2);
				if (!result)result = HasSubtree(pRoot1->right, pRoot2);
			}
		}
		return result;

	}

	bool isEqueal(TreeNode*pRoot1, TreeNode*pRoot2)//HasSubtree call isEqual(p1,p2),p1->val=p2->val;
	{
		if (pRoot2==NULL)
		{
			return true;
		}
		if (pRoot1==NULL)
		{
			return false;
		}
		if (pRoot1->val != pRoot2->val)
			return false;
		return isEqueal(pRoot1->left, pRoot2->left) && isEqueal(pRoot1->right, pRoot2->right);//self call self:p1-val==p2->val is not always satisfy 
	}
};
```

`思路`这道题参照了书上的解法，首先我是想到了分成两部分来处理的，可能没那么清楚，再加上没想到用两个递归，我觉得把问题子规摸化的确是很重要的，要是在一个函数里写，应该是很复杂的。主要是先找到一个和pRoot->val相等的节点，然后用一个递归函数判断是否含有子结构。

### 二叉树的镜像

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>

using namespace std;

struct TreeNode {
int val;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int x) :
val(x), left(NULL), right(NULL) {
}
};
class Solution {
public:
	void Mirror(TreeNode *pRoot) {
		if (pRoot == NULL)
			return;
		TreeNode*temp = pRoot->left;
		pRoot->left = pRoot->right;
		pRoot->right = temp;
		Mirror(pRoot->left);
		Mirror(pRoot->right);
	}
};

int main()
{
	Solution solver;
	return 0;
}
```

`思路` 简单，交换左子树和右子树，再分别对左子树和右子树递归调用即可

### 顺时针打印矩阵

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	vector<int> printMatrix(vector<vector<int> > matrix) {
		vector<int>result;
		if (matrix.size() == 0)return result;

		int row_num = matrix.size();
		int col_num = matrix[0].size();
		int col = 0,row=0,d_col=0,d_row=0;
		int count = 0;
		if (row_num % 2 == 0)
		{
			count = row_num / 2;
		}
		else
		{
			count = row_num / 2 + 1;
		}
		while (row<count)
		{
            //col++
			col = d_col;
			while (col<col_num-d_col)
			{
				result.push_back(matrix[row][col]);
				col++;
			}
            //row++
			row = d_row+1;
			col = col_num - d_col - 1;
			while (row<row_num-d_row-1&&col>=d_col)//优先打印列，所以要小于row_num-d_row-1
			{
				result.push_back(matrix[row][col]);
				row++;
			}
            //col--
			row = row_num - d_row-1;
			col = col_num - d_col-1;
			while (col>=d_col&&row>d_row)
			{
				result.push_back(matrix[row][col]);
				col--;
			}
            //row--
			row=row_num-d_row-2;//优先打印列，所以要-2
			col = d_col;
			while (row>d_row&&col<col_num-d_col-1)
			{
				result.push_back(matrix[row][col]);
				row--;
			}
			d_col++;
			d_row++;
			row = d_row;//下一轮打印的row起始位置
		}
		return result;
	}
};

int main()
{
	Solution solver;
	vector<vector<int>> vec;

	int num = 1;
	for (int i = 1; i <6; i++)
	{
		vector<int>temp;
		for (int j = 1; j < 2; j++)
		{
			temp.push_back(num);
			num++;
		}
		vec.push_back(temp);
	}
	vector<int>a=solver.printMatrix(vec);
	return 0;
}
```

`思路`方法简单，但是边界等小问题很重要，很容易出错。两层循环，第一层循环决定打印多少圈，如果是基数，就打印row_num/2圈，否则打印row_num/2+1圈；第二层循环打印分成四步：col++、row++、col--、row--，每一步打印之前都需要给row和col重新赋值，不然容易出现越界的问题,每一步打印的判断条件一定要考虑清楚，不然可能会出现重复打印、少打印、数组越界等情况，这个地方我调试了很久，所以要反复斟酌，想清楚每个的条件应该怎么写。另外，由于选择`优先`打印`列`，能保证行和列不会出现重复打印的情况。

### 包含min函数的栈

```c++

#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	vector<int>sta;
	int min_val;
	void push(int value) {
		if (sta.empty())min_val = value;
		else
		{
			if (value < min_val)min_val = value;
		}
		sta.push_back(value);
	}
	void pop() {
		vector<int>::iterator it = sta.end() - 1;
		
		sta.erase(it);
		if (*it == min_val)
		{
			min_val = sta[0];
			for (int i = 0; i < sta.size(); i++)
			{
				if (min_val > sta[i])min_val = sta[i];
			}
		}
	}
	int top() {
		return *(sta.end()-1);
	}
	int min() {
		return min_val;
	}
};

int main()
{
	Solution solver;
	for (int i = 1; i < 5; i++)
	{
		solver.push(i);
	}
	solver.pop();
	cout<<" "<<solver.top()<<" "<<solver.min();
	return 0;
}
```

`思路`这题主要是考虑两点：

- min()函数的时间复杂度是$O(1)$,因此需要用一个变量在push的过程中存储最小值；
- 在pop的过程中，有可能会pop最小值，因此需要在pop中更新最小值；

### 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
//
//测试用例:
//[1], [2]
//
//对应输出应该为 :
//
//	false
//
//	你的输出为 :
//
//	true
class Solution {
public:
	vector<int> st;
	bool IsPopOrder(vector<int> pushV, vector<int> popV) {
		int j = 0;
		int k = -1;
		for (int i = popV.size()-1; i>=0 ; i--)
		{
			
			if(j>=pushV.size())
			{
				if (st[k] != popV[i])return false;
				k--;
			}
			else
			{
				while (j<pushV.size()&&pushV[j]!=popV[i])
				{
					st.push_back(pushV[j]);
					k++;
					j++;
				}
				if (j >= pushV.size())
				{
					i++;
				}
				j++;

			}
		}
		return true;
	}
};

int main()
{
	vector<int> popV, pushV;
	/*for (int i = 1; i < 6; i++)
	{
		pushV.push_back(i);
		popV.push_back(i);
	}
	popV[4] = 4; popV[3] = 5; */
	popV.push_back(2);
	pushV.push_back(1);

	Solution solver;
	solver.IsPopOrder(pushV, popV);
	return 0;
}
```

`思路`想清晰之后再写代码会事半功倍，如果还没完全想清楚就直接写代码，再根据错误来调试，很可能会陷入僵局。这题的思路是这样：模拟一个push和pop的整个过程；以popV序列作为外循环，目的是从弹出序列第一个开始遍历，定义一个成员变量`st`,while循环中不断的忘栈`st`压入数据，一旦和弹出栈的元素相等，就不压入栈，相当于说压入又弹出了。当pushV序列中的元素遍历完成，而popV序列中的元素还没遍历完成，则将popV中剩余的元素一一和st中的元素对比，这时候两者顺序是一致的。

还有一个地方需要注意的是，测试用例中存在这种popV序列和pushV序列元素不一致的情况：[1],[2]

###  从上到下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

 

```c++


#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
struct TreeNode {
int val;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int x) :
val(x), left(NULL), right(NULL) {
}
};
class Solution {
public:
	bool flag=false;
	//vector<int> PrintFromTopToBottom(TreeNode* root) {
	//	vector<int> result;
	//	if (root == NULL)return result;
	//	if (!flag)
	//	{
	//		result.push_back(root->val);
	//		flag = true;
	//	}
	//	if (root->left != NULL)result.push_back(root->left->val);
	//	if (root->right != NULL)result.push_back(root->right->val);

	//	vector<int> temp=PrintFromTopToBottom(root->left);
	//	result.insert(result.end(), temp.begin(), temp.end());

	//	temp=PrintFromTopToBottom(root->right);
	//	result.insert(result.end(), temp.begin(), temp.end());
	//	return result;
	//}
//BFS
	vector<int> PrintFromTopToBottom(TreeNode* root) {
		vector<int> result;
		if (root == NULL)return result;
		queue<TreeNode*>queue_tree;
		queue_tree.push(root);

		while (!queue_tree.empty())
		{
			TreeNode* pNode = queue_tree.front();
			queue_tree.pop();

			result.push_back(pNode->val);
			if (pNode->left != NULL)
			{
				queue_tree.push((pNode->left));
			}
			if (pNode->right != NULL)
			{
				queue_tree.push(pNode->right);
			}

		}
		return result;
	}
};
int main()
{
	Solution solver;
	return 0;
}
```

`思路`这道题的思路就是BFS，利用队列，将二叉树的节点指针保存在队列中，然后在出队列的时候打印；要判断root==NULL的情况。对于注释掉的那个函数，也是可以通过的，对于第一次调用PrintFromTopToBottom函数，要将根节点push_back，而后面的递归调用都不需要，这里有个递归调用顺序的问题，感觉应该是错的。。。不知道为啥通过了；正确的应该是用BFS：



### 二叉树的后序遍历序列

```c++

#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
struct TreeNode {
int val;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int x) :
val(x), left(NULL), right(NULL) {
}
};
class Solution {
public:
	bool flag=false;
	//vector<int> PrintFromTopToBottom(TreeNode* root) {
	//	vector<int> result;
	//	if (root == NULL)return result;
	//	if (!flag)
	//	{
	//		result.push_back(root->val);
	//		flag = true;
	//	}
	//	if (root->left != NULL)result.push_back(root->left->val);
	//	if (root->right != NULL)result.push_back(root->right->val);

	//	vector<int> temp=PrintFromTopToBottom(root->left);
	//	result.insert(result.end(), temp.begin(), temp.end());

	//	temp=PrintFromTopToBottom(root->right);
	//	result.insert(result.end(), temp.begin(), temp.end());
	//	return result;
	//}

	vector<int> PrintFromTopToBottom(TreeNode* root) {
		vector<int> result;
		if (root == NULL)return result;
		queue<TreeNode*>queue_tree;
		queue_tree.push(root);

		while (!queue_tree.empty())
		{
			TreeNode* pNode = queue_tree.front();
			queue_tree.pop();

			result.push_back(pNode->val);
			if (pNode->left != NULL)
			{
				queue_tree.push((pNode->left));
			}
			if (pNode->right != NULL)
			{
				queue_tree.push(pNode->right);
			}

		}
		return result;
	}

	bool VerifySquenceOfBST(vector<int> sequence) {

		int len = sequence.size();
		if (len == 0)return false;
		int root = sequence[len - 1];
		int root_idx = 0;
		vector<int> right, left;
		for(int i=len-2;i>=0;i--)
		{ 
			if (sequence[i] < root)
			{
				for (; i >= 0; i--)
				{
					if (sequence[i] > root)return false;
					left.push_back(sequence[i]);
				}
			}
			else
			{
				right.push_back(sequence[i]);
			}
		}
		reverse(left.begin(), left.end());
		reverse(right.begin(), right.end());

		if (left.size()!=0&&!VerifySquenceOfBST(left))return false;
		if (right.size() != 0 && !VerifySquenceOfBST(right))return false;

		return true;
	}
};
int main()
{
	Solution solver;
	vector<int> vec;
	vec.push_back(5);
	vec.push_back(7);
	vec.push_back(6);
	vec.push_back(9);
	vec.push_back(11);
	vec.push_back(10);
	vec.push_back(8);

	solver.VerifySquenceOfBST(vec);
	return 0;
}
```

`思路`主要是要明白BST的性质：左子树的节点都小于根节点，而右子树的节点都大于根节点。最后一个节点为根节点，根据这个性质找到分界位置，然后判断左子树是否有大于根节点的节点，有则返回false，否则递归判断左右子树。

`二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。`

### 二叉树中和为某一值的路径(！有问题)

```c++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
	vector<vector<int>> path;
    //排序函数
	bool comp(vector<int> a, vector<int>b) { return a.size() > b.size(); }
	vector<vector<int> > FindPath(TreeNode* root, int expectNumber) {
		if (root == NULL)return path;

		vector<int>cur_pth;
		int cur_val = 0;
		find_cur_pth(root, expectNumber, cur_val, cur_pth);

		//sort(path.begin(), path.end(),comp );
		return path;
	}

	void  find_cur_pth(TreeNode* root, int expectNumber,int cur_val,vector<int>cur_pth)
	{
		cur_val += root->val;
		cur_pth.push_back(root->val);
        //当前节点为根节点,而且当前值和expectNumber相等
		if (cur_val == expectNumber&&root->left == NULL&& root->right==NULL)
		{
			path.push_back(cur_pth); 
		}
        //递归访问左右子树
		else if(cur_val<expectNumber)
		{
			if(root->left!=NULL)find_cur_pth(root->left, expectNumber, cur_val, cur_pth);
			if (root->right != NULL)find_cur_pth(root->right, expectNumber, cur_val, cur_pth);
		}
        //返回到父节点之前要弹出当前节点，以方便上一级递归能顺利访问右子树；
		cur_val -= root->val;
		cur_pth.pop_back();
	}
};
```

`思路`目前这个代码是通过的，但是我感觉还是有点问题，因为现在的代码是把排序的地方注释掉了的，但是题目中要求是排序的。我估计是牛客网上是没有stl的sort函数的。

思路就是创建成员变量vector<vector<int>> path;来保存所有路径，通过FindPath函数调用find_cur_pth，而find_cur_pth是递归的先序遍历树，从而保存遍历过程中所有可能的路径。



### 复杂链表的复制(未通过)

```c++
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
	RandomListNode* Clone(RandomListNode* pHead)
	{
		if (pHead == NULL) return NULL;
		RandomListNode* head =NULL,*cur_p=pHead,*temp=NULL,*temp1;
		while (cur_p!=NULL)
		{
			temp = cur_p->next;
			cur_p->next = new RandomListNode(cur_p->label);
			cur_p->next->next = temp;
			cur_p = temp;
		}
		cur_p = pHead;
		while (cur_p != NULL)
		{
			temp = cur_p->next;
			if (cur_p->random != NULL)temp->random = cur_p->random->next;
			cur_p = temp->next;

		}
		cur_p = pHead;
		head = pHead->next;
		temp = head;
		while (temp->next !=NULL)
		{
			cur_p->next = temp->next;
			cur_p = cur_p->next;
			temp->next = temp->next->next;
			temp = temp->next;
		}
		return head;
	}
};
```

`思路`按照剑指offer上的解释写的，但是它把我的输出判断为空了，但是我并不是直接返回的pHead，本地试了一个例子也是通过的；迷茫啊。。。



### 二叉搜索树（BST）与双向链表

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

struct TreeNode {
int val;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int x) :
val(x), left(NULL), right(NULL) {
}
};
class Solution {
public:
	TreeNode*head = NULL,*cur=NULL;
	TreeNode* Convert(TreeNode* pRootOfTree)
	{
		if (pRootOfTree == NULL)return NULL;
		if (pRootOfTree->left != NULL)Convert(pRootOfTree->left);
		if (head == NULL)
		{
			head = pRootOfTree;
			cur = head;
		}
		else
		{
			cur->right = pRootOfTree;
			cur->right->left = cur;
			cur = cur->right;
		}
		if (pRootOfTree->right != NULL)Convert(pRootOfTree->right);

		return head;
	}
};


int main()
{
	Solution solver;
	return 0;
}
```

`思路`这道题基本是一遍通过。思路比较简单，就是一个中序遍历；使用两个全局指针，一个指向头结点，一个指向当前最后节点，已方便往后面添加节点。

### 字符串的排列(重要，有变种)

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:

	vector<string> s;
	int cur_pos = -1;
	bool isEqual = true;
	vector<string> Permutation(string str) {
		if (str.size() == 0)return s;
		cur_pos++;
		if (cur_pos == str.size() - 1)
		{
			s.push_back(str);
		}
		else
		{
			for (int i = cur_pos; i < str.size(); i++)
			{
				bool isSwap = true;
				for (int j = cur_pos; j < i; j++)
				{
					if (str.at(j) == str.at(i))isSwap = false;
				}
				if (isSwap)
				{
					char temp = str.at(i);
					//swap
					str.at(i) = str.at(cur_pos);
					str.at(cur_pos) = temp;

					Permutation(str);
					//swap back
					temp = str.at(i);
					str.at(i) = str.at(cur_pos);
					str.at(cur_pos) = temp;
				}
			}

		}
		cur_pos--;

		sort(s.begin(), s.end());
		return s;
	}
};

int main()
{
	Solution solver;
	solver.Permutation("abc");
	return 0;
}
```

`思路`参考了[解答](https://blog.csdn.net/puqutogether/article/details/41692307)。还是递归的思想，但是要考虑到存在重复字符的问题。也就是以下代码的判断能去重：

```c++
bool isSwap = true;
for (int j = cur_pos; j < i; j++)
{
	if (str.at(j) == str.at(i))isSwap = false;
}
```

这个地方我并不是很清楚，自己也没有想到为什么要这么做，算是比较有技巧性的问题吧。**这一类问题还有，要注意总结**

### 数组中出现次数超过一半的数

```c++

	#include<iostream>
	#include <algorithm>
	#include<string>
	#include<vector>
	#include<stack>
	using namespace std;
	class Solution {
	public:
		int a[10000] = {0};
		int MoreThanHalfNum_Solution(vector<int> numbers) {
			for (int i = 0; i < numbers.size(); i++)
			{
				a[numbers.at(i)]++;
				if (a[numbers.at(i)] > (numbers.size() / 2))return numbers.at(i);
			}
			return 0;
		}
	};
	
	int main()
	{
		Solution solver;
		return 0;
	}
```

`思路`此题有些投机取巧了，直接估计他的数字大小不超过10000，然后用数字作为索引，遇到一个数字，对应索引的值就加1，加一次就判断是否超过一半，超过则返回即可；前提是此题只有一个或者没有数字出现次数超过一半。 

###  最小的k个数

```c++

	#include<iostream>
	#include <algorithm>
	#include<string>
	#include<vector>
	#include<stack>
	using namespace std;
	class Solution {
	public:
		int a[1000] = {0};
		vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
			vector<int> result;
			if (k > input.size())return result;
			for (int i = 0; i < input.size(); i++)
			{
				a[input.at(i)]++;
			}
			int i = 0, count = 0;

			while (count<k)
			{
				if (a[i] != 0)
				{
					count += a[i];
					result.push_back(i);
				}

				i++;
			}
			return result;
		}
	};
	
	int main()
	{
		Solution solver;

		vector<int>a;
		a.push_back(4);
		a.push_back(5);
		a.push_back(1);
		a.push_back(6);
		a.push_back(2);
		a.push_back(7);
		a.push_back(3);
		a.push_back(8);
		solver.GetLeastNumbers_Solution(a, 4);
		return 0;
	}
```

`思路`这道题任然是借助数组a来做，由于题目中没有重复的数字，count += a[i];result.push_back(i);这两句相当于每次只加了一个。如果有重复的数字则需要根据题目要求再确定是否允许有重复的最小k个数字。



### 连续子数组的最大和

```c++
class Solution {
public:
		int max_val=0;
		int FindGreatestSumOfSubArray(vector<int> array) {
			if (array.size() == 0)return 0;
			max_val = array[0];
			int cur_sum = 0;

			for (int i = 0; i< array.size(); i++)
			{
				cur_sum += array[i];
				if (cur_sum < array[i])cur_sum = array[i];
				if (cur_sum > max_val)max_val = cur_sum;
			}
			return max_val;
		}
};
```

`思路`一个全局变量max_val保存最大和，初始化为数组第一个元素。接下来用cur_sum保存当前和，一旦和小于当前元素本身，则令和为当前元素（因为都小于当前元素本身了，前面的元素和都是可以舍弃的。），否则就继续往后面加；当cur_sum大于max_val时，要更新max_val的值。



### 整数中1出现的次数（重要，特别是代码风格，用了很多较好的内建函数）

```c++
class Solution {
public:
		int NumberOf1Between1AndN_Solution(int n)
		{
			if (n < 0)return 0;
			char strN[50];
			sprintf(strN, "%d",n);
			return NumberOf1(strN);
		}
		int NumberOf1(const char*strN)
		{
			if (!strN || *strN<'0' || *strN>'9' || *strN == '\0')return 0;
			int first = *strN - '0';
			unsigned int length = static_cast<unsigned int>(strlen(strN));
			//一位数的情况
			if (length == 1 && first == 0)return 0;
			if (length == 1 && first > 0)return 1;


			int numFirstDigit = 0;
            //1)
			//第一位数不为1的情况，例如21345那就要处理10000~19999的情况，也就是有10^4个1
			if (first > 1)numFirstDigit = PowerBase10(length - 1);
			else if(first==1)//第一位为1，比如11345，那么第一位只有1个1，后面有可能有1345中数								//字，总的就是在高位出现1346个1（这个地方比较难想到）
			{ 
				numFirstDigit = atoi(strN + 1) + 1;
			}
            //2)
            //其他位有1的情况(排列组合的思想)：除了最高位，剩下位中选1，有（length-1）种可能，接下			//来的各位在0-9之间选一个，10^(length-2)种情况，还要乘上最高位的取值可能。
			int numOfOtherDigits = first*(length - 1)*PowerBase10(length - 2);
            //3)
            //通过递归实现后面各位
			int numRecursive = NumberOf1(strN + 1);

			return numFirstDigit + numOfOtherDigits + numRecursive;
		}
		int PowerBase10(unsigned int n)
		{
			int result = 1;
			for (unsigned int i = 0; i < n; i++)
			{
				result *= 10;
			}
			return result;
		}
};
```

`思路`这道题照着剑指offer上解的。我自己倒是想到了递归的思想，单数不太清除每一级递归该怎么算。这里的解法是分成三部分，分析见代码。

### 把数组排成最小的数(自定义sort函数的使用)

```c++
bool cmp(const  vector<int>&a, const  vector<int>&b)
	{
		/*return a.size() < b.size();*/
		vector<int>ab, ba;

		ab.insert(ab.end(), a.begin(), a.end());
		ab.insert(ab.end(), b.begin(), b.end());

		ba.insert(ba.end(), b.begin(), b.end());
		ba.insert(ba.end(), a.begin(), a.end());
		bool flag = true;
		for (int i = 0; i < ab.size(); i++)
		{
			if (ab[i] != ba[i])
			{
				if (ab[i] > ba[i])
				{
					flag = false;
				}
					break;
			}
			
		}
		return flag;
	}
class Solution {
public:

		string PrintMinNumber(vector<int> numbers) {
			if (numbers.size() == 0)return "";
			if(numbers.size() == 1)return to_string(numbers[0]);

			vector<vector<int>> my_number;//二维数组保存该数组，第二维是每个数字；
			my_number.resize(numbers.size());

			int max_len = 0;
			for (int i = 0; i < numbers.size(); i++)
			{
				char strN[50];
				sprintf(strN, "%d", numbers[i]);
				for (int j=0;strN[j]!='\0';j++)
				{
					my_number[i].push_back(strN[j]-'0');
				}
				if (my_number[i].size() > max_len)max_len = my_number[i].size();
			}//将数字保存成单个字符的二维数组

			sort(my_number.begin(), my_number.end(), cmp);//根据自定义的cmp进行排序，两两组合，组合后更小的排在前面。
			string result;
			for (int i = 0; i < my_number.size(); i++)//根据排序结果转换成字符串
			{
				for (int j = 0; j < my_number[i].size(); j++)
				{
					result += to_string(my_number[i][j]);
				}
			}
			return result;
		}
};
```

`思路`这道题参考了剑指offer，也想到了两两排序，但是没仔细忘下想：该怎么排序，此处的关键也就是cmp函数。也算学会了自定义sort函数的使用

### 第n个丑数

**笨办法**

```c++
class Solution {
public:
		int GetUglyNumber_Solution(int index) {
			int m=0, n=0, k = 0,cur_idx=1;
			int a = 2;
			while (cur_idx<index)
			{
				if (isUglyNumber(a))cur_idx++;
				a++;
			}
			return --a;
		}
		bool isUglyNumber(int number)
		{
			while (number%2==0)
			{
				number /= 2;
			}
			while (number%3==0)
			{
				number /= 3;
			}
			while (number%5==0)
			{
				number /= 5;
			}

			if (number != 1)return false;
			return true;
		}
};
```

**降低时间复杂度的方案（时间换空间）**

```c++
class Solution {
public:
		int GetUglyNumber_Solution(int index) {
			if (index <= 0)return 0;

			int* pUglyNumbers = new int[index];
			pUglyNumbers[0] = 1;
			int nextIdx = 1;
			int *pUgly2 = pUglyNumbers;//指向当前位置
			int *pUgly3 = pUglyNumbers;
			int *pUgly5 = pUglyNumbers;
			while (nextIdx<index)
			{

				pUglyNumbers[nextIdx] = Min(*pUgly2*2,*pUgly3*3,*pUgly5*5);
				//找到小于pUglyNumbers[nextIdx]分别乘2,3,5的丑数，也就是乘2,3,5离pUglyNumbers[nextIdx]最近的丑数
				while (*pUgly2*2<=pUglyNumbers[nextIdx])
				{
					++pUgly2;
				}
				while (*pUgly3 * 3 <= pUglyNumbers[nextIdx])
				{
					++pUgly3;
				}
				while (*pUgly5 * 5 <= pUglyNumbers[nextIdx])
				{
					++pUgly5;
				}
				nextIdx++;
			}
			int ug_num = pUglyNumbers[nextIdx - 1];
			delete[]pUglyNumbers;
			return ug_num;
		}


		int Min(int a, int b, int c)
		{
			int min = (a < b) ? a : b;
			min = (min < c) ? min : c;
			return min;
		}
};
```

`思路`按照剑指offer的解答做的，这个方法没想到，就是省略了非丑数的计算，第二层循环反复乘2计算的次数也比前面方法反复取模运算次数少。用空间换时间，把离当前丑数最近的丑数记下位置，并保存所有前面的丑数。

时间复杂度：$O(n)$

空间复杂度：$O(n)$

### 第一个只出现一次的字符（时空平衡）

```c++
	struct Info
	{
		int count;
		int pos;
	};
class Solution {
public:
		map<char, Info> m;
		int FirstNotRepeatingChar(string str) {
			if (str.size() == 0)return -1;
			std::map<char, Info>::iterator it;
			for (int i = 0; i < str.size(); i++)
			{
				it = m.find(str.at(i));
				if (it != m.end())
					m[str.at(i)].count++;
				else
				{
					m[str.at(i)].count = 1;
					m[str.at(i)].pos = i;
				}
			}
			int pos= 10000;
			for (it = m.begin(); it != m.end(); it++)
			{
				if (it->second.count == 1)
				{
					if (it->second.pos < pos)pos = it->second.pos;
				}
			}
			return pos;
		}
};
```

`思路`比较简单，用一个map保存每个字符出现的位置和次数，最多有26*2个key;位置和次数用一个结构体Info保存，作为键的value；

**时间复杂度**：$O(n)$，hash查找key是否存在的速度很快，是$O(1)$的时间复杂度；

**空间复杂度**：$O(1)$,因为52个值作为键的辅助数组，数组大小是一个常数；

### 数组中的逆序对（归并排序）

```c++
class Solution {
public:
		int InversePairs(vector<int> data) {
			if (data.size() == 0)return 0;
			vector<int>copy;
			copy.insert(copy.end(), data.begin(), data.end());
			long long result= getInverseCount(data, copy, 0, data.size() - 1) % 1000000007;
			return result;

		}
		long long getInverseCount(vector<int>&data , vector<int>&copy, int start, int end)
		{
	
			if (start == end) {
				copy[start]=data[start];
				return 0;
			}
			int len = (end - start) / 2;
			long long left = getInverseCount(copy, data, start, start + len);
			long long right = getInverseCount(copy, data, start + len + 1, end);

			//归并排序:从最后一个元素往前归并排序
			int i = start + len;
			int j = end;
			int idx_sorted = end;
			long long count = 0;
			while (i >= start&&j >= start + len + 1)
			{
				if (data[i] > data[j])
				{
					copy[idx_sorted] = data[i];
					i--;
					idx_sorted--;
					count += j - start - len;
				}
				else
				{
					copy[idx_sorted]= data[j];
					j--;
					idx_sorted--;
				}
			}

			for (; i >= start; i--)
			{
				copy[idx_sorted] = data[i];
				idx_sorted--;
			}
			for (; j >= start + len + 1; j--)
			{
				copy[idx_sorted] = data[j];
				idx_sorted--;
			}

			return left + right + count;
		}
};
```

`思路`这个题采用了递归子问题求解和归并排序；子问题就是一分为二，每次比较都只和相邻元素比较，是在归并排序的时候比较计算逆序数对并排序的，而且有一个trick就是每个子问题都从最后一个元素往前归并排序,这样就能保证每次能计算好几个逆序数对，就是说当前元素的前面元素都是有序的，这也就是每次递归调用的时候需要把data和copy交换一下的原因，因为把其中一当成一个媒介，缓存一下。

还有一个地方特别需要注意，题目中说的很清楚：

```
数据范围：	对于%50的数据,size<=10^4	对于%75的数据,size<=10^5	对于%100的数据,size<=2*10^5
```

所以逆序数对的存放必须要用`long long`，如果用int，就只能通过一半的测试。一定要细心！这个问题找了很久，最后还是对着别人的代码发现的。

>  作者：牛客8918164号
> 链接：<https://www.nowcoder.com/questionTerminal/96bd6684e04a44eb80e6a68efc0ec6c5>
> 来源：牛客网
>
> 交换copy和data是因为：
> 1.在每次的操作中，数值的比较都是采用当前传入函数中第一项，也就是data；比较的结果都存放到copy中；也就意味着此时copy中是经过此次调用的结果。
> 2.从最底层返回时，进入了(start == end)的情形，data 和 copy 完全没有修改，此时copy和data还是一样的。
> 3.进入倒数第二层时，程序进入上图26行以后部分，copy是部分排序后的新数组，data是旧数组。注意这里都是传值的调用，数组都是直接修改的。
> 倒数第二层使用的copy其实是倒数第三层中的data,这就确保了倒数第三层进入26行以后时，数据比较使用的data是最新排序的数组。
> \4. 倒数第三层将排序的结果存入copy中。程序在倒数第四层进入26行后，使用的data数组为刚刚倒数第三层中的最新排序的copy.
> \5. 也就是说，在每次程序进入26行时，此时的data是最新的排序结果，copy是次新的结果。
>    在最后一次进入26行以后时，copy为完整排序后的结果，data是次新的结果。
>    然而这里第一个类内函数调用第二个函数时，data和copy的顺序没有改变，所以最后结果应该copy是完整排序的结果.data是差一步完成排序的结果。以输入[7,5,6,4], 最后的结果copy[4,5,6,7], data[5,7,4,6].  



### 两个链表的第一个公共节点

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
	ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) {
		map<ListNode*, int>m;

		ListNode*a=pHead1, *b=pHead2;

		while (a!=NULL)
		{
			m[a] = 1;
			a = a->next;
		}
		map<ListNode*, int>::iterator it;
		while (b!=NULL)
		{
			it=m.find(b);
			if (it != m.end())
			{
				return b;
			}
			b = b->next;
		}
		return NULL;
	}
};
```

`思路`这道题还是比较简单的，直接用map保存每个节点指针，指针作为key ，先遍历一遍链表pHead1，再在另一个链表中遍历，直到找到key存在则返回；找不到就返回空。

时间复杂度：$O(n)$

空间复杂度也是一样。



