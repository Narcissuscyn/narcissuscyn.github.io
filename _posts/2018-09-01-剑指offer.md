---
  layout: post
  title:  "剑指offer"
  date:   2018-09-01 13:50:39
  categories: jekyll
  mathjax: true
---

### 剑指offer

* content
{:toc}
### 二维数组中的查找

`我的思想`：此题在于边界的考虑，算法思想是在每一行进行一个二分查找

```python
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # array=np.array(array)
        # write code here
        if array==[[]]:
            return False
        l = len(array[0])
        row=array.__len__()
        for i in range(row):
            min = 0
            max=l
            pre=-1
            idx=0
            while(pre!=idx):
                idx = int(((min + max)/2))
                pre=idx
                if target < array[i][idx]:
                    max=idx
                    idx =int(((idx+min) / 2))
                elif target > array[i][idx]:
                    min=idx
                    idx =int(( (idx + max) / 2))
                else:
                    return True
        return False
array=[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
solve=Solution()
if solve.Find(7,array):
    print("yes")
else:
    print("No")
```

`更好解答`：

### 替换空格

```c++
#include<iostream>

#include<string>
using namespace std;

class Solution {
public:
	void replaceSpace(char *str, int length) {
		string a = "";
		int idx = 0;
		for (int i = 0; i < length; i++)
		{

			if (str[i] != ' ')
			{
				//a.push_back(str[i]);
				a.append(sizeof(char), str[i]);
				//cout << (typeid(str[i])== typeid(char));
				idx++;

			}
			else
			{
				idx += 3;
				a.append("%20");
			}
		}
		str=strcpy(str, a.c_str());

		//str = (char*)a.c_str();这个方法提交不成功，只修改了形参str，上面那句话可以！这个地方需要仔细研究下赋值问题，类似swap(a,b)
	}
};

int main()
{
	Solution solver;
	solver.replaceSpace("hello world", 11);
	getchar();
	return 0;
}

```

`string 字符串拼接的几种方法:`

```c++
y:string d:char，d是string可以直接append(d)
1)y += d
2)std::string y("Hello worl");
y.push_back('d')
3)s.append(sizeof(char), d);
4）s.append(1, d);
```

`将string转换成char*字符串`:

```c++
data();

如：

string str="abc";

charp=(char)str.data();

2.c_str();

如：

string str="adcd";

char p=(char)str.c_str();

```

`O(n)的复杂度`，用python当然简单了这题，几行代码搞定。

### 从尾到头打印链表

```c++
#include<iostream>

#include<string>
#include<vector>
using namespace std;


struct ListNode {
	int val;
    struct ListNode *next;
    ListNode(int x) :
		val(x), next(NULL) {
       }
};


class Solution {
public:
	//3 从头到尾打印链表
	vector<int> printListFromTailToHead(ListNode* head) {
		vector<int> a,b;
		if (head == NULL)
		{
			return a;
		}
		ListNode* temp = head;
		while (temp!=NULL)
		{
			cout << temp->val;
			a.push_back(temp->val);
			temp = temp->next;
		}
		for (int i = a.size()-1; i >=0 ; i--)
		{
			b.push_back(a[i]);
		}
		return b;
	}
};

int main()
{
	Solution solver;
	ListNode*head = NULL;
	head =new ListNode(1);
	head->next= new ListNode(2);
	solver.printListFromTailToHead(head);
	getchar();
	return 0;
}
```

这个题目比较简单遍历两次即可。第二个遍历也可利用#include <algorithm> 中的排序函数`reverse(a.begin(),a.end()) `其实现如下：

```c++
template <class BidirectionalIterator> void reverse (BidirectionalIterator first, BidirectionalIterator last)
{
     while ((first!=last)&&(first!=--last))
     {
          std::iter_swap (first,last);
          ++first;
     }
}
```

我试了vector的reverse，，没成功：

```c++
arrayInt=...
vector<int> arrayRever;
arrayRever.reserve(arrayInt.size());
```

![1534345792071](C:\Users\nian.000\AppData\Local\Temp\1534345792071.png)

### 根据先序和中序建立二叉树

```c++
TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		//只有一个节点，直接返回该节点
		if (pre.size() == 1|| vin.size()==1)
		{
			return  new TreeNode(pre[0]);
		}
		//寻找先序的头结点在中序序列中的位置
		int root_val = pre.front();
		TreeNode*root = new TreeNode(root_val);

		vector <int>::iterator it = find(vin.begin(),vin.end(), root_val);
		int nPosition = -1;
		if (it != vin.end())
		{
			nPosition = distance(vin.begin(), it);
		}
		//建立左子树和右子树
		vector<int> l_vin, r_vin;
		vector<int> l_pre,r_pre;
		if (nPosition == 0)//左子树为空
		{
			root->left = NULL;
		}
		else//得到左子树的pre和vin序列，并递归调用。
		{
			l_pre=vector<int>(&pre[1], &pre[nPosition]);
			l_pre.push_back(pre[nPosition]);
			l_vin.assign(vin.begin(), it);
			root->left = reConstructBinaryTree(l_pre, l_vin);
			
		}
		if (nPosition == vin.size() - 1)//右子树为空
		{
			root->right = NULL;
		}
		else//得到右子树的pre和vin序列，并递归调用。
		{
			r_pre=vector<int>(&pre[nPosition+1], &pre[pre.size()-1]);
			r_pre.push_back(pre[pre.size() - 1]);
			r_vin.assign(it+1,vin.end() );
			root->right = reConstructBinaryTree(r_pre, r_vin);
		}
		
		return root;
	}
```

`主要思想:`在于`递归`的创建左子树和右子树。

`复制vector一部分的两种方法：`

- ```c++
  1.l_vin.assign(vin.begin(), it);
  2.l_pre=vector<int>(&pre[1], &pre[nPosition]);
  //注意：第二种方法是前闭后开的。第一种方法是闭的。
  ```

`根据中序和后续序列创建二叉树：`和根据先序和中序创建二叉树的道理是一样的，只是后序序列的根节点是最后一个节点。

### 用两个栈实现队列

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

class Solution
{
public:
	void push(int node) {
		if (stack1.empty())
		{
			stack1.push(node);
		}
		else
		{
			while (!stack1.empty())
			{
				stack2.push(stack1.top());
				stack1.pop();
			}
			stack2.push(node);
			while (!stack2.empty())
			{
				stack1.push(stack2.top());
				stack2.pop();
			}

		}
	}

	int pop() {
		int a = stack1.top();
		stack1.pop();
		return a;
	}

private:
	stack<int> stack1;
	stack<int> stack2;
};

int main()
{
	Solution solver;
	solver.push(1);
	solver.push(2);
	solver.push(3);
	solver.pop();
	return 0;
}
```

`思路：`将数据存在一个栈中，在push的时候通过令一个栈中转，实现把数据压入底部，pop的时候可以直接利用stack的pop即可；当然反过来pop的时候利用另一个栈中转，push的时候直接利用stack的push也是可以的。

### 旋转数组的最小值

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	int minNumberInRotateArray(vector<int> rotateArray) {
		int len = rotateArray.size();
		if (len == 0)
		{
			return 0;
		}
		else
		{
			int da = 1;
			for (int i = 1; i < len; i++)
			{
				da = rotateArray[i] - rotateArray[i - 1];
				if (da < 0)//小于0即递减的位置
				{
					return rotateArray[i];
				}
			}
		}
		return rotateArray[0];
	}
};

int main()
{
	Solution solver;
	//3.
	//input:3 4 5 1 2 s
	vector<int> a;
	int val = 0;
	while (cin >> val)
	{
		a.push_back(val);
	}
	cout << solver.minNumberInRotateArray(a) << endl;
	getchar();
	return 0;
}
```

`思路`只要找到递减的位置输出即可

### 斐波那契数列

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

//F0 = 0     (n = 0)
//F1 = 1    (n = 1)
//Fn = F[n - 1] + F[n - 2](n = >2)
int a[10000] = { 0 };
class Solution {
public:
	
	int Fibonacci(int n) {
		if (n == 0)
		{
			a[0] = 0;
			return 0;
		}
		else if(n==1)
		{
			a[1] = 1;
			return 1;
		}
		if (a[n] == 0)
		{
			a[n] = Fibonacci(n - 1) + Fibonacci(n - 2);
			return a[n];
		}
		else
		{
			return a[n];
		}

	}
};

int main()
{
	Solution solver;
	cout<<solver.Fibonacci(4);
	getchar();
	return 0;
}
```

`思路`[参考文章](https://github.com/qiwsir/algorithm/blob/master/fibonacci.md)，如果直接用递归而不存储中间结果的话，肯定是超时的，因此要用一个数组保存前面已经计算的结果。还有一些快速实现的思路，以下来自参考文章：

- 用迭代的方式实现：

  ```python
  def fib3(n):
      a, b = 0, 1
      for i in range(n):
          a, b = b, a+b
      return a
  ```

- 用数学理论结论：

  ```python
  print('!* Fibonacci Sequence python \n')
  def Fibonacci_Series():
      x = input('Enter Series length to print fibonacci sequence')
  
      d,e=0,1
      a = []
      a.append(d)
      a.append(e)
      while(x!=2):
          c = d + e
          d = e
          e = c
          a.append(c)
          x = x -1
      print(a)
  ```

### (8,9)跳台阶

- 每次1-2台阶

  ```c++
  class Solution {
  public:
  int a[10000] = { 0 };
  	//in the n-th floor
  	int jumpFloor(int number) {
  		if ((number == 1) || (number == 0)||(number==2))
  		{
  			return number;
  		}
  		if (a[number] == 0)
  		{
  			a[number] = jumpFloor(number - 1) + jumpFloor(number - 2);
  			return a[number];
  		}
  		return a[number];
  	}
  };
  ```

  和问题7的解法一样。

- 每次1-n个台阶

  ```c++
  class Solution {
  public:
      int a[10000] = { 0 };
  //dynamic programing?no!
  	int jumpFloorII(int number) {
  		if (number == 1 || number == 0)
  		{
  			return 1;
  		}
  		if (a[number] == 0)
  		{
  			a[number] = 2 * jumpFloorII(number - 1);
  		}
  		return a[number];
  	}
  };
  ```

  `思路`关键是推导数关系式 $ Fib(n) = 2*Fib(n-1) $,[参考文章](https://blog.csdn.net/Hackbuteer1/article/details/6686747)

### 矩形覆盖

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	int a[100000] = { 0 };
	int rectCover(int number) {

		if (number == 0)
		{
			return 0;
		}
		if (number == 1 || number == 2)
		{
			return number;
		}
		if (a[number] == 0)
		{
			a[number] = rectCover(number - 2)+rectCover(number-1);
		}
		return a[number];
	}
};
int main()
{
	Solution solver;
	cout<<solver.rectCover(3);

	return 0;
}
```

`思路`其实和前两题类似，主要考虑n来自于哪几种情况，再递归的加起来即可，这题，2*n的覆盖来自于2*(n-1)和2(n-2)两种情况。

### 二进制数中1的个数

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
#include<math.h>
using namespace std;
class Solution {
public:
	vector<int>a;
	int  NumberOf1(int n) {
		bool flag = true;
		if (n < 0)
		{
			flag = false;
		}
		n = abs(n);
		while (n!=0)
		{
			if (n % 2 == 1)
			{
				a.push_back(1);
			}
			else
			{
				a.push_back(0);
			}
			n = n / 2;

		}
		if (!flag)
		{
			while (a.size()<31)
			{
				a.push_back(0);
			}
			a.push_back(1);

			for (int i = 0; i < a.size()-1; i++)//reverse
			{
				if (a[i] == 1)
				{
					a[i] = 0;
				}
				else
				{
					a[i] = 1;

				}
			}
			for (int i = 0; i < a.size()-1; i++)//add 1
			{
				a[i] += 1;
				if (a[i] == 2)
				{
					a[i] = 0;
				}
				else
				{
					break;
				}
			}
			

		}
		
		int count = 0;
		for (int i = 0; i < a.size(); i++)
		{
			if (a[i] == 1)
			{
				count++;
			}
		}
		return count;
	}
};

int main()
{
	//-2147483648
	Solution solver;
	cout<<solver.NumberOf1(-1);
	return 0;
}
```

`思路`这个题目主要是要考虑整型(`int`)是32位的.当n为负数时要在第32位添加1，其它位要取反加1.

### 数值的整数次方

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	double Power(double base, int exponent) {
		bool flag = true;
		double result = 1;
		if (exponent < 0)
		{
			flag = false;
			exponent = -exponent;
		}
		for (int i = 0; i < exponent; i++)
		{
			result *= base;
		}
		if (!flag)
		{
			result = 1 / result;
		}
		return result;
	}
};

int main()
{
	Solution solver;
	solver.Power(2, -3);
	return 0;
}
```

`思路`这题主要是要考虑到指数为负数的情况。

### 调整数组顺序使奇数位于偶数前面

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	void reOrderArray(vector<int> &array) {
		vector<int> old,even;
		for (int i = 0; i < array.size(); i++)
		{
			if (array[i] % 2 == 0)
			{
				even.push_back(array[i]);
			}
			else
			{
				old.push_back(array[i]);
			}
		}
		old.insert(old.end(), even.begin(), even.end());
		array = old;

	}
};

int main()
{
	Solution solver;
	return 0;
}
```

`思路`两个数组分别存奇数和偶数，再把偶数拼接在奇数后面即可，最后由于array是引用，直接赋值给array即可；

### 链表中倒数第k个节点

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;

struct ListNode {
int val;
struct ListNode *next;
ListNode(int x) :
val(x), next(NULL) {
}
};
class Solution {
public:
	ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL||pListHead->next==NULL)
		{
			return NULL;
		}
		ListNode* node_k= pListHead, *nex= pListHead;

		int interval = 0;

		while (nex->next!=NULL)
		{
			nex = nex->next;
			interval ++;
		}
		if (interval < k-1)
		{
			return NULL;
		}
		else
		{
			while (interval>k-1)
			{
				node_k = node_k->next;
				interval--;
			}
		}		
		return node_k;
	}
};

int main()
{
	Solution solver;
	ListNode*head= new ListNode(0), *tail = NULL;
	//head->next = new ListNode(1);
	tail = head;
	for (int i = 1; i <= 5; i++)
	{
		tail->next = new ListNode(i);
		tail = tail->next;
	}
	solver.FindKthToTail(head, 1);
	return 0;
}
```

`思路`用两个指针，一个指针遍历到最后一个节点，记住这期间经过了多好次->next，也就是interval的值，然后另一个指针也从头向尾遍历，直到interval减少至k-1

这里需要注意的地方就是输入的链表，第一个节点就是head节点，它同时是有值的，比如说输入{1,2,3,4,5}那么head节点的值就是1，接下来2,3,4,5

### 反转链表

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
	ListNode* ReverseList(ListNode* pHead) {
		if (pHead == NULL)
			return NULL;
		if (pHead->next == NULL)
			return pHead;
		ListNode*temp, *tail=pHead->next,*pre=pHead;
		while (tail->next != NULL)
		{
			temp = tail->next;//保存当前节点的下一节点
			tail->next = pre;//更改当前节点的指针指向上一节点
			pre = tail;//pre保存当前节点
			tail = temp;//tail指向temp
		}
		tail->next = pre;//最后一个节点的指针也要更新下
		pHead->next = NULL;//更新头节点的指针
		return tail;
	}
};
```

### 合并两个排序链表

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
	{
		if (pHead1 == NULL &&pHead2 == NULL)
			return NULL;

		if (pHead1 == NULL)return pHead2;
		if (pHead2 == NULL) return pHead1;
		ListNode*temp_big, *temp_small,*final, *temp=NULL;

		if (pHead1->val < pHead2->val)
		{
			temp_big = pHead2;
			temp_small = pHead1;
		}
		else
		{
			temp_big = pHead1;
			temp_small = pHead2;
		}
		final = temp_small;
		
		while (temp_small!=NULL)
		{
			//循环处理temp_small，当temp_small的值大于temp_big时交换指针
			while (temp_small!=NULL &&temp_small->val<=temp_big->val)
			{
				temp = temp_small;
				temp_small = temp_small->next;
			}
			if (temp_small != NULL)
			{
				temp->next = temp_big;
				temp=temp_small;
				temp_small = temp_big;//这个地方不能赋值为temp_big->next，因为temp_big->next为空时，下面那句赋值语句会没有变量指向final的尾指针。
				temp_big = temp;
			}
		}
		if (temp_big != NULL)
		{
			temp->next = temp_big;//多出来的部分加上去
		}
		return final;
	}
};
```

`思路`这道题其实不用新建链表，不断的交换指针即可。有点需要注意：

- temp_small遍历到空指针时要考虑将剩下的temp_big里的节点接到final上去；

### 树的子结构

```c++
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
	val(x), left(NULL), right(NULL) {
	}
};

class Solution {
public:
	bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
	{
		bool result = false;
		if (pRoot1 != NULL&&pRoot2 != NULL)
		{
			if (pRoot1->val == pRoot2->val)
			{
				result = isEqueal(pRoot1, pRoot2);
				if (!result)result = HasSubtree(pRoot1->left, pRoot2);
				if (!result)result = HasSubtree(pRoot1->right, pRoot2);
			}
		}
		return result;

	}

	bool isEqueal(TreeNode*pRoot1, TreeNode*pRoot2)//HasSubtree call isEqual(p1,p2),p1->val=p2->val;
	{
		if (pRoot2==NULL)
		{
			return true;
		}
		if (pRoot1==NULL)
		{
			return false;
		}
		if (pRoot1->val != pRoot2->val)
			return false;
		return isEqueal(pRoot1->left, pRoot2->left) && isEqueal(pRoot1->right, pRoot2->right);//self call self:p1-val==p2->val is not always satisfy 
	}
};
```

`思路`这道题参照了书上的解法，首先我是想到了分成两部分来处理的，可能没那么清楚，再加上没想到用两个递归，我觉得把问题子规摸化的确是很重要的，要是在一个函数里写，应该是很复杂的。主要是先找到一个和pRoot->val相等的节点，然后用一个递归函数判断是否含有子结构。

### 二叉树的镜像

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>

using namespace std;

struct TreeNode {
int val;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int x) :
val(x), left(NULL), right(NULL) {
}
};
class Solution {
public:
	void Mirror(TreeNode *pRoot) {
		if (pRoot == NULL)
			return;
		TreeNode*temp = pRoot->left;
		pRoot->left = pRoot->right;
		pRoot->right = temp;
		Mirror(pRoot->left);
		Mirror(pRoot->right);
	}
};

int main()
{
	Solution solver;
	return 0;
}
```

`思路` 简单，交换左子树和右子树，再分别对左子树和右子树递归调用即可

### 顺时针打印矩阵

```c++
#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	vector<int> printMatrix(vector<vector<int> > matrix) {
		vector<int>result;
		if (matrix.size() == 0)return result;

		int row_num = matrix.size();
		int col_num = matrix[0].size();
		int col = 0,row=0,d_col=0,d_row=0;
		int count = 0;
		if (row_num % 2 == 0)
		{
			count = row_num / 2;
		}
		else
		{
			count = row_num / 2 + 1;
		}
		while (row<count)
		{
            //col++
			col = d_col;
			while (col<col_num-d_col)
			{
				result.push_back(matrix[row][col]);
				col++;
			}
            //row++
			row = d_row+1;
			col = col_num - d_col - 1;
			while (row<row_num-d_row-1&&col>=d_col)//优先打印列，所以要小于row_num-d_row-1
			{
				result.push_back(matrix[row][col]);
				row++;
			}
            //col--
			row = row_num - d_row-1;
			col = col_num - d_col-1;
			while (col>=d_col&&row>d_row)
			{
				result.push_back(matrix[row][col]);
				col--;
			}
            //row--
			row=row_num-d_row-2;//优先打印列，所以要-2
			col = d_col;
			while (row>d_row&&col<col_num-d_col-1)
			{
				result.push_back(matrix[row][col]);
				row--;
			}
			d_col++;
			d_row++;
			row = d_row;//下一轮打印的row起始位置
		}
		return result;
	}
};

int main()
{
	Solution solver;
	vector<vector<int>> vec;

	int num = 1;
	for (int i = 1; i <6; i++)
	{
		vector<int>temp;
		for (int j = 1; j < 2; j++)
		{
			temp.push_back(num);
			num++;
		}
		vec.push_back(temp);
	}
	vector<int>a=solver.printMatrix(vec);
	return 0;
}
```

`思路`方法简单，但是边界等小问题很重要，很容易出错。两层循环，第一层循环决定打印多少圈，如果是基数，就打印row_num/2圈，否则打印row_num/2+1圈；第二层循环打印分成四步：col++、row++、col--、row--，每一步打印之前都需要给row和col重新赋值，不然容易出现越界的问题,每一步打印的判断条件一定要考虑清楚，不然可能会出现重复打印、少打印、数组越界等情况，这个地方我调试了很久，所以要反复斟酌，想清楚每个的条件应该怎么写。另外，由于选择`优先`打印`列`，能保证行和列不会出现重复打印的情况。

### 包含min函数的栈

```c++

#include<iostream>
#include <algorithm>
#include<string>
#include<vector>
#include<stack>
using namespace std;
class Solution {
public:
	vector<int>sta;
	int min_val;
	void push(int value) {
		if (sta.empty())min_val = value;
		else
		{
			if (value < min_val)min_val = value;
		}
		sta.push_back(value);
	}
	void pop() {
		vector<int>::iterator it = sta.end() - 1;
		
		sta.erase(it);
		if (*it == min_val)
		{
			min_val = sta[0];
			for (int i = 0; i < sta.size(); i++)
			{
				if (min_val > sta[i])min_val = sta[i];
			}
		}
	}
	int top() {
		return *(sta.end()-1);
	}
	int min() {
		return min_val;
	}
};

int main()
{
	Solution solver;
	for (int i = 1; i < 5; i++)
	{
		solver.push(i);
	}
	solver.pop();
	cout<<" "<<solver.top()<<" "<<solver.min();
	return 0;
}
```

`思路`这题主要是考虑两点：

- min()函数的时间复杂度是$O(1)$,因此需要用一个变量在push的过程中存储最小值；
- 在pop的过程中，有可能会pop最小值，因此需要在pop中更新最小值；





