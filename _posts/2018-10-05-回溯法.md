---
layout: post
title:  "回溯法"
date:   2018-10-05 17:40:41
categories: 剑指offer
tags: 回溯法
mathjax: true
author:Narcissus
---

* content
{:toc}
### 矩阵中的路径

```c++
class Solution {
public:
	bool hasPath(char* matrix, int rows, int cols, char* str)
	{
		bool* mat_flag = new bool[rows*cols]{false};
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < cols; j++)
			{
				if (matrix[i*cols+j] == str[0])
				{
					if (path(matrix, mat_flag, rows, cols, i, j, 0, str))//找到第一个元素匹配的地方，然后开始递归调用
					{
						return true;
					}
				}
			}
		}
		return false;
	}
	bool path(char* matrix,bool*mat_flag, int rows, int cols, int i, int j, int char_pos, char*str)//递归调用函数
	{
		if (str[char_pos] == '\0')return true;
		if ((!mat_flag[i*cols + j])&&(str[char_pos] == matrix[i*cols + j]))
		{
			if (str[char_pos+1] == '\0')return true;//考虑到str只有一个元素的情况;也算是边界条件
			mat_flag[i*cols + j] = true;
			bool up=false, down=false, left=false, right=false;
			if (i - 1 >= 0)up = path(matrix, mat_flag, rows, cols, i - 1, j, char_pos + 1, str);//向上走一格
			if (i + 1 < rows)down = path(matrix, mat_flag, rows, cols, i + 1, j, char_pos + 1, str);//向下走一格
			if(j-1>=0)left= path(matrix, mat_flag, rows, cols, i, j-1, char_pos + 1, str);//向左走一格
			if(j+1<cols)right= path(matrix, mat_flag, rows, cols, i, j+1, char_pos + 1, str);//向右走一格
			if (up || down || right || left)return true;//只要有一条路线成功就可以了
			mat_flag[i*cols + j] = false;//不成功则要回溯，因此mat_flag[i*cols + j]要置为未访问过的

		}
		return false;
	}

};
```

`思路`这道题我能自己写出来，还是蛮欣慰的，这几天刷题以及画画和科研的状态，觉得自己心态成熟了许多，很多问题并不是自己做不到，而是不够静心。着急的都是得不到满意的结果的，心态很重要。



### 机器人的运动范围

```c++
class Solution {
public:
	int movingCount(int threshold, int rows, int cols)
	{
		bool*mat_flag = new bool[rows*cols]{ false };//标识进入过的格子
		move(mat_flag, threshold, rows, cols, 0, 0);
		int count = 0;
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < cols; j++)
			{
				count += mat_flag[i*cols+j];
			}
		}

		return count;
	}

	void move(bool * mat_flag, int thresh, int rows, int cols, int i, int j)
	{
        //&&mat_flag[i*cols + j]!=true注意这个判断条件，只要进入这个格子a之后，就没必要再次进入这个格子a，因为一旦从某一路径进入格子a，通过格子a能到达的格子都将能进入，即使从其他路径进入格子a,接下来的路径也是重复的，没有必要的。所以一定要加上这个条件；一方面是避免重复计算，另一方面是防止死循环。
		if (i<rows&&j<cols&&mat_flag[i*cols + j]!=true&&isEnter(i, j, thresh))
		{
			mat_flag[i*cols + j] = true;
			if (i - 1 >= 0)move(mat_flag, thresh, rows, cols, i - 1, j);//分别向四个方向走动
			if (i + 1 < rows)move( mat_flag, thresh, rows, cols, i + 1, j);
			if (j - 1 >= 0)move(mat_flag, thresh, rows, cols, i, j - 1);
			if (j + 1 < cols)move( mat_flag, thresh, rows, cols, i, j + 1);
		}
	}

	bool isEnter(int i, int j,int thresh)//判断是否可以进入该格子
	{
		int sum = 0;
		while (i!=0)
		{
			sum += i % 10;
			i /= 10;
		}
		while (j!=0)
		{
			sum += j % 10;
			j /= 10;
		}
		return thresh>=sum;
	}
};
```

简单，但要注意写代码的严谨性，细节要注意，否则半天找不到问题在哪。